---
title: "Custom Differential Expression Analysis Playground"
author: "tucca-rna-seq"
date: "`r Sys.Date()`"
bibliography:
  - grateful-refs.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/nature.csl
link-citations: true
output:
  rmdformats::readthedown:
    code_folding: hide
    self_contained: true
    number_sections: true
    DT: datatable
    toc_depth: 3
    collapsed: true
    css: css/doc.css
    fig_width: 15
    fig_height: 15
    classoption: landscape
---

# Introduction

This RMarkdown document is a playground for performing your own custom
differential expression (DE) analysis and visualization. It is designed to be a
starting point, demonstrating how to load results from the `tucca-rna-seq`
workflow and perform common downstream analysis steps.

Unlike the other more automated playgrounds (`GeneTonic`, `pcaExplorer`, `ideal`),
this script is meant to be edited directly. You can use the code chunks below
as templates for creating publication-quality figures and custom analyses.

Before you begin, make sure you have successfully completed a `tucca-rna-seq`
run. The objects generated by the pipeline are required for this analysis.

# Setup

## Load Libraries

First, we load all the necessary R packages.

```{r setup, message=FALSE, warning=FALSE}
# Bootstrap the 'here' package. This ensures that `here` is installed before
# we use it to find the project root.
if (!base::requireNamespace("here", quietly = TRUE)) {
  utils::install.packages("here", quiet = TRUE)
}

# The `here` package helps us build file paths relative to the project root.
here::i_am("tucca-rna-seq/analysis/customDE_playground.Rmd")

# We explicitly tell renv where its project directory is.
renv::restore(
  project = here::here("tucca-rna-seq"), prompt = FALSE, clean = TRUE
)

# All functions in this notebook will be called with explicit package namespaces
# (e.g., `DESeq2::plotMA()`) to ensure clarity and avoid conflicts.
# This makes `library()` calls unnecessary.
```

# Possible Configurations

This chunk reads your `config.yaml` to show which analyses and contrasts are
available to explore.

```{r possible-configurations}
# Parse the YAML string into an R list
config_path <- here::here("tucca-rna-seq", "config", "config.yaml")
config <- yaml::read_yaml(config_path)

# Extract the list of analyses
analyses_list <- config$diffexp$deseq2$analyses

# Use lapply to iterate over each analysis and extract its contrasts
analysis_contrast_map <- base::lapply(analyses_list, function(analysis) {
  base::sapply(analysis$contrasts, `[[`, "name")
})

# Assign the analysis names to the list elements
base::names(analysis_contrast_map) <- base::sapply(analyses_list, `[[`, "name")

# Print the resulting R list with a descriptive header
base::cat(
  "Available analyses (as list names) and their corresponding",
  "contrasts (as list values):\n\n"
)
base::print(analysis_contrast_map)
```

# Your Configuration

Here, you need to specify which analysis and contrast you want to explore.
These names correspond to the configurations in your `config.yaml`.

```{r configuration}
# --- USER INPUT REQUIRED ---
# The values below are examples from the default `config.yaml`.
# Replace them with the `analysis` and `contrast` you wish to explore.
analysis_name <- "treatment1_treatment2"
contrast_name <- "treatment1_treated_vs_untreated"

# Get analysis parameters from config
alpha <- config$diffexp$deseq2$p_adj_cutoff
lfc_threshold <- config$diffexp$deseq2$lfc_threshold
```

# Load Workflow Results

Now, we load the data generated by the `tucca-rna-seq` pipeline based on the
configuration above. We will load three key objects:

-   `dds`: The main `DESeqDataSet` object, containing counts and metadata.
-   `dst`: The `DESeqTransform` object with variance-stabilized data (e.g., rlog),
    ideal for visualizations like PCA and heatmaps.
-   `res_de`: The `DESeqResults` object for your chosen contrast.

```{r load_data}
# Construct file paths
dds_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, "dds.RDS"
)
dst_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, "dst.RDS"
)
wald_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, contrast_name,
  "wald.RDS"
)

# Load the objects
dds <- base::readRDS(dds_path)
dst <- base::readRDS(dst_path)
res_de <- base::readRDS(wald_path)
```

# Preparing Annotations for Results Tables

To make our results tables more informative, we first need to map our gene IDs
(e.g., ENSEMBL IDs) to more common gene symbols or names. The following code
chunk loads the appropriate organism annotation database (`OrgDb`) and creates
an `annotation_obj` that we can use to enrich our results.

```{r create_annotation_obj}
# Load the enrichment parameters that were used in the Snakemake run
enrichment_params_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", "enrichment_params.RDS"
)
enrichment_params <- base::readRDS(enrichment_params_path)

# Get OrgDb package name from the loaded parameters.
# This logic mirrors the pipeline scripts to correctly identify the package
# name, whether it was installed from Bioconductor or built locally.
install_method <- enrichment_params$install_method
install_source <- enrichment_params$install_source

# Determine the actual package name
org_db_pkg <- if (install_method == "local") {
  # When built locally, find the package name from the build directory.
  local_build_path <- here::here("tucca-rna-seq", install_source)
  pkg_dirs <- base::list.dirs(
    path = local_build_path,
    full.names = FALSE, recursive = FALSE
  )
  pkg_name <- pkg_dirs[grepl("^org\\..+\\.db$", pkg_dirs)]
  if (base::length(pkg_name) == 0) {
    base::stop(
      "Could not find a locally built OrgDb package in the specified",
      "directory: ", local_build_path
    )
  }
  pkg_name[1]
} else {
  enrichment_params$org_db_pkg
}

base::message("Attempting to load OrgDb package: ", org_db_pkg)

# Set a default value for annotation_obj
annotation_obj <- NULL

# Try to load the package. If it's not there, try to install it.
if (!base::require(org_db_pkg, character.only = TRUE)) {
  base::message("Package not found, attempting installation via renv...")
  tryCatch(
    {
      if (install_method == "local") {
        # For a locally built package, we need to provide the path to renv
        local_pkg_path <- here::here("tucca-rna-seq", install_source)
        base::message(
          "Attempting to install local package from: ",
          local_pkg_path
        )
        # We point renv to the directory containing the package source
        renv::install(local_pkg_path, prompt = FALSE)
      } else {
        # For remote packages, renv can find it by name from Bioconductor
        base::message("Attempting to install remote package: ", org_db_pkg)
        renv::install(org_db_pkg, prompt = FALSE)
      }
    },
    error = function(e) {
      base::message(base::paste("Installation of", org_db_pkg, "failed."))
      base::message("Original error: ", e$message)
    }
  )
}

# Now, try to load it again. If it works, create the annotation object.
if (base::require(org_db_pkg, character.only = TRUE)) {
  # Determine the keytype based on the genome annotation source from config.yaml
  ref_source <- config$ref_assembly$source
  keytype <- if (ref_source %in% base::c("Ensembl", "GENCODE")) {
    "ENSEMBL"
  } else if (ref_source == "RefSeq") {
    "ENTREZID"
  } else {
    base::warning(base::paste(
      "Unrecognized ref_assembly.source:", ref_source,
      "- defaulting keytype to ENSEMBL."
    ))
    "ENSEMBL"
  }

  base::message(base::paste(
    "Using", org_db_pkg, "for annotation with keytype '", keytype, "'."
  ))

  # The annotation object needs columns: 'gene_id', 'gene_name'
  # We will map from the appropriate gene IDs based on the keytype
  keys <- utils::head(base::rownames(dds))

  # Determine the correct column for gene symbols
  all_cols <- AnnotationDbi::columns(base::get(org_db_pkg))
  symbol_col_candidates <- base::c("SYMBOL", "GENENAME")
  symbol_col <- NULL

  for (candidate in symbol_col_candidates) {
    if (candidate %in% all_cols) {
      symbol_col <- candidate
      base::message("Found '", symbol_col, "' as the gene symbol column.")
      break
    }
  }

  if (base::is.null(symbol_col)) {
    base::stop("Could not find a suitable gene symbol column in this OrgDb.")
  }

  annotation_obj <- AnnotationDbi::select(
    base::get(org_db_pkg),
    keys = AnnotationDbi::keys(base::get(org_db_pkg), keytype = keytype),
    columns = base::c(symbol_col),
    keytype = keytype
  ) |>
    dplyr::rename(
      gene_id = dplyr::all_of(keytype),
      gene_name = dplyr::all_of(symbol_col)
    ) |>
    dplyr::filter(!base::is.na(gene_name))
} else {
  base::message(
    "OrgDb package could not be loaded. Please ensure the pipeline",
    "has run successfully and that you are in the correct R environment."
  )
}
```

# Exploratory Data Analysis & QC

Before diving into the differential expression results, it's crucial to perform
some quality control to understand the structure of your data. These unsupervised
clustering methods are run using variance-stabilized transformed counts (e.g.,
`rlog` or `vst`) to improve distance calculations and visualization.

## Principal Component Analysis (PCA)

Principal Component Analysis (PCA) is a technique used to emphasize variation
and bring out strong patterns in a dataset (dimensionality reduction). PC1 and
PC2 represent the sources of greatest variation in the dataset. We expect
samples from the same experimental group to cluster together.

```{r plot-pca}
# The `intgroup` argument specifies which variable(s) from the colData to use
# for coloring and shaping the points.
p_pca <- DESeq2::plotPCA(dst, intgroup = base::c("treatment1", "treatment2")) +
  ggplot2::labs(title = "PCA of Variance-Stabilized Counts") +
  ggplot2::theme_bw()
p_pca
```

## Hierarchical Clustering Heatmap

Similar to PCA, hierarchical clustering is another, complementary method for
identifying strong patterns in a dataset and potential outliers. This heatmap
shows the Euclidean distance between samples, which provides a view of sample
similarity. The dendrogram illustrates how samples are clustered.

### A Note on Color Palettes

Choosing the right color palette is crucial for creating clear and effective
visualizations. R has excellent support for color palettes through several
packages. For high-quality, colorblind-friendly, and perceptually uniform
palettes, we recommend exploring:

-   **`RColorBrewer`**: Offers a set of palettes for sequential, diverging, and
    qualitative data.
-   **`viridis`**: Provides beautiful, colorblind-friendly palettes.
-   **`scico`**: A collection of scientific color maps based on the work of Fabio Crameri.

For a comprehensive overview of nearly every color palette package available in
R, this GitHub resource is an invaluable guide:
[**r-color-palettes** by Emil Hvitfeldt](https://github.com/EmilHvitfeldt/r-color-palettes).

Below is an example of how to apply a custom color palette from `scico`
to the sample distance heatmap.

```{r plot-heatmap-distances}
# Extract the variance-stabilized matrix
vst_mat <- SummarizedExperiment::assay(dst)

# Compute pairwise distances
sample_dists <- stats::dist(base::t(vst_mat))
sample_dist_matrix <- base::as.matrix(sample_dists)

# Get metadata for annotation
metadata <- SummarizedExperiment::colData(dst) |> base::as.data.frame()

# Define a color palette from scico.
# You can explore other palettes by changing the `palette` argument.
# See `?scico::scico` for options.
heatmap_colors <- scico::scico(n = 100, palette = "lajolla")

# Generate colors for metadata annotations.
# This code dynamically creates a named list of colors for each column
# in your metadata, which can be passed to pheatmap.
annotation_colors <- base::list()
for (colname in base::names(metadata)) {
  if (base::is.factor(metadata[[colname]]) || base::is.character(metadata[[colname]])) {
    unique_vals <- base::unique(metadata[[colname]])
    if (base::length(unique_vals) <= 9) {
      # Use a qualitative palette for few categories
      palette <- RColorBrewer::brewer.pal(n = base::length(unique_vals), name = "Set1")
    } else {
      # Use a scico palette for more categories
      palette <- scico::scico(n = base::length(unique_vals), palette = "berlin")
    }
    base::names(palette) <- unique_vals
    annotation_colors[[colname]] <- palette
  }
}

# Plot the heatmap
p_heatmap_dist <- ggplotify::as.ggplot(pheatmap::pheatmap(
  sample_dist_matrix,
  clustering_distance_rows = sample_dists,
  clustering_distance_cols = sample_dists,
  annotation_col = metadata,
  annotation_colors = annotation_colors,
  main = "Sample Distance Matrix",
  color = heatmap_colors,
  silent = TRUE
))
p_heatmap_dist
```

## Dispersion Estimates

This plot is a key diagnostic for DESeq2. It shows how gene-wise dispersion
estimates (black dots) are shrunk towards a fitted trend (red line). This
shrinkage helps moderate variance for more stable DE analysis, especially with
small sample sizes. The blue dots are the final, shrunken estimates used in
the statistical testing.

```{r plot-dispersion}
p_disp <- ggplotify::as.ggplot(~ DESeq2::plotDispEsts(
  dds,
  cex.lab = 1.0,
  cex.axis = 1.0,
  cex.sub = 1.0
))
p_disp
```

# Analyzing DE Results

Now we'll visualize the results for the specific contrast you selected. We will
use the significance cutoff (`p_adj_cutoff`) and log2 fold-change threshold
(`lfc_threshold`) defined in `config/config.yaml`.

## MA Plot

The MA plot shows the log2 fold change for each gene against its mean of
normalized counts. Genes with an adjusted p-value below a certain threshold
(e.g., 0.05) are typically colored, highlighting them as significant. This plot
helps to identify the magnitude of fold changes and their relationship with
average expression.

```{r plot-ma}
p_ma <- ggplotify::as.ggplot(~ DESeq2::plotMA(
  res_de,
  ylim = base::c(-4, 4), # Adjust ylim as needed
  main = base::paste("MA Plot for:", contrast_name)
))
p_ma
```

## Volcano Plot

A volcano plot is another way to visualize DE results, plotting statistical
significance (-log10 adjusted p-value) against the magnitude of change (log2
fold change). It provides a quick visual identification of genes with large
fold changes that are also statistically significant. The cutoffs for significance
are drawn from `config.yaml` (p-adj < `r alpha`, |log2FC| > `r lfc_threshold`).

For this, we recommend the `EnhancedVolcano` package, which creates highly
customizable plots.

```{r plot-volcano}
# Convert results to a data frame for plotting
res_df <- base::as.data.frame(res_de)

# To label specific genes, create a vector of gene symbols.
# Example:
# genes_to_label <- base::c("GENE1", "GENE2", "ANOTHER_GENE")
#
# You can then pass this vector to the `selectLab` argument. Note that your
# results data frame must have a column with gene symbols. The code below
# assumes your row names are gene symbols.
p_volcano <- EnhancedVolcano::EnhancedVolcano(
  res_df,
  lab = base::rownames(res_df),
  x = "log2FoldChange",
  y = "padj",
  title = base::paste("Volcano Plot for:", contrast_name),
  subtitle = base::paste0("Log2 FC cutoff = ", lfc_threshold, "; p-adj cutoff = ", alpha),
  pCutoff = alpha,
  FCcutoff = lfc_threshold,
  pointSize = 2.0,
  labSize = 4.0,
  # selectLab = genes_to_label, # Uncomment to label your specific genes
  drawConnectors = TRUE, # Often useful with selectLab
  # The arguments below are available in your fork of EnhancedVolcano.
  # 'box.padding' increases the length of the connectors.
  box.padding = 0.5,
  # 'matchLabelColorsToSig' colors the labels based on significance.
  matchLabelColorsToSig = TRUE
)
p_volcano
```

# Visualizing Individual DE Genes

## Heatmap of Top DE Genes

To visualize the expression patterns of the most significant genes, we can
create a heatmap. Here, we'll plot the top 20 DE genes (by adjusted p-value)
across all samples. The expression values are from the variance-stabilized data
and are scaled per gene (Z-score) to focus on relative changes rather than
absolute expression levels.

```{r plot-de-heatmap}
# Get top 20 significant genes. You can change the number or filtering logic.
# For example, to get all significant genes:
# sig_genes <- res_de |>
#   as.data.frame() |>
#   dplyr::filter(padj < 0.05) |>
#   rownames()
top_genes <- res_de |>
  base::as.data.frame() |>
  dplyr::arrange(padj) |>
  utils::head(20) |>
  base::rownames()

# Extract normalized, transformed counts for these genes
vst_mat <- SummarizedExperiment::assay(dst)
top_gene_mat <- vst_mat[top_genes, ]

# Plot heatmap
p_heatmap_de <- ggplotify::as.ggplot(pheatmap::pheatmap(
  top_gene_mat,
  cluster_rows = TRUE,
  show_rownames = TRUE,
  cluster_cols = TRUE,
  annotation_col = metadata,
  annotation_colors = annotation_colors,
  scale = "row", # Scale genes to have mean 0 and SD 1 (Z-score)
  main = "Top 20 DE Genes",
  clustering_method = "ward.D2",
  border_color = NA,
  color = scico::scico(100, palette = "vik"),
  # Define symmetric breaks for the color scale for Z-scores.
  # Adjust the range (-3, 3) if your Z-scores have a wider spread.
  breaks = base::seq(-3, 3, length.out = 101),
  # Additional parameters for aesthetics and clarity
  fontsize = 10,
  cutree_cols = 2, # Cut column dendrogram into 2 clusters
  legend_breaks = base::c(-3, 0, 3),
  legend_labels = base::c("Low", "Medium", "High"),
  silent = TRUE
))
p_heatmap_de
```

# Exploring DE Results in Data Tables

While plots are great for seeing the big picture, data tables are essential for
drilling down into the details. This section demonstrates how to create
interactive tables of your DE results.

```{r create-results-tables}
# Convert the DESeqResults object to a data frame and add annotations
res_df_annotated <- res_de |>
  base::as.data.frame() |>
  tibble::rownames_to_column(var = "gene_id") |>
  dplyr::left_join(annotation_obj, by = "gene_id") |>
  # Round numeric columns for readability
  dplyr::mutate(dplyr::across(tidyselect::where(is.numeric), ~ base::round(.x, 3)))

# Create clickable links for gene IDs and symbols
species_name <- config$ref_assembly$species
res_df_linked <- res_df_annotated |>
  dplyr::mutate(
    # Create ENSEMBL links if the source is Ensembl/GENCODE
    gene_id_link = dplyr::case_when(
      config$ref_assembly$source %in% base::c("Ensembl", "GENCODE") ~
        base::paste0(
          "<a href='http://www.ensembl.org/", species_name,
          "/Gene/Summary?g=", gene_id, "' target='_blank'>", gene_id, "</a>"
        ),
      TRUE ~ gene_id
    ),
    # Create NCBI links for gene symbols
    gene_symbol_link = base::paste0(
      "<a href='http://www.ncbi.nlm.nih.gov/gene/?term=",
      gene_name, "' target='_blank'>", gene_name, "</a>"
    )
  ) |>
  # Reorder columns to be more intuitive
  dplyr::select(
    gene_id_link, gene_symbol_link, baseMean, log2FoldChange, padj,
    tidyselect::everything()
  )

# Filter for significant genes
res_sig <- res_df_linked |>
  dplyr::filter(padj < alpha & base::abs(log2FoldChange) > lfc_threshold)

# Separate into up- and down-regulated
res_up <- res_sig |> dplyr::filter(log2FoldChange > 0)
res_down <- res_sig |> dplyr::filter(log2FoldChange < 0)
```

## Full DE Results Table

This table contains the complete, annotated results for the selected contrast.

```{r table-full-results, echo=FALSE}
DT::datatable(
  res_df_linked,
  escape = FALSE, # Important to render HTML links
  caption = "Full annotated DE results",
  options = base::list(scrollX = TRUE)
)
```

## Significant DE Genes

This table shows genes that pass the significance cutoffs defined in your
`config.yaml` (p-adj < `r alpha` and |log2FC| > `r lfc_threshold`).

```{r table-sig-results, echo=FALSE}
DT::datatable(
  res_sig,
  escape = FALSE,
  caption = "Significant DE genes",
  options = base::list(scrollX = TRUE)
)
```

### Upregulated Genes

```{r table-up-results, echo=FALSE}
DT::datatable(
  res_up,
  escape = FALSE,
  caption = "Significantly upregulated genes",
  options = base::list(scrollX = TRUE)
)
```

### Downregulated Genes

```{r table-down-results, echo=FALSE}
DT::datatable(
  res_down,
  escape = FALSE,
  caption = "Significantly downregulated genes",
  options = base::list(scrollX = TRUE)
)
```

# Arranging and Saving Plots with `cowplot`

One of the major advantages of converting all plots to `ggplot` objects is the
ability to easily arrange them into multi-panel figures using packages like
`cowplot`. Below is an example of how you can combine some of the plots we've
created into a single figure and save it to a file.

```{r arrange-plots}
# Arrange plots into a 2x2 grid
final_figure <- cowplot::plot_grid(
  p_pca, p_volcano, p_ma, p_heatmap_de,
  labels = base::c("A", "B", "C", "D"),
  ncol = 2,
  align = "hv"
)

# Print the figure to the notebook
final_figure

# Save the figure to a file
# cowplot::save_plot(
#   "my_de_analysis_figure.png",
#   final_figure,
#   base_height = 10,
#   base_width = 12
# )
```

# R Session Information

Below is the output of the R session used to generate this report.

```{r sessionInfo}
utils::sessionInfo()
```

# References

```{r citation-reports, message=FALSE, warning=FALSE, echo=TRUE}
# Packages to cite
dependencies <- renv::dependencies()
pkgs <- base::unique(dependencies$Package)

# Create grateful citation report
grateful::cite_packages(
  output = "file",
  out.format = "html",
  citation.style = "nature",
  out.dir = here::here("tucca-rna-seq", "analysis"),
  pkgs = pkgs,
  cite.tidyverse = FALSE,
  include.RStudio = FALSE, # Set to FALSE for automated testing.
  passive.voice = TRUE
)
```

```{r citation-table, message=FALSE, warning=FALSE, echo = TRUE}
pkgs_tbl <- grateful::cite_packages(
  output = "table",
  citation.style = "nature",
  out.dir = here::here("tucca-rna-seq"),
  pkgs = pkgs,
  cite.tidyverse = FALSE,
  include.RStudio = FALSE # Set to FALSE for automated testing.
)
pkgs_tbl$Citation <- base::gsub("\\.\\.\\.\\.", "", pkgs_tbl$Citation)
knitr::kable(pkgs_tbl)
```
