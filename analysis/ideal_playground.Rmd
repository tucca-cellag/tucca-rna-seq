---
title: "Interactive Analysis with ideal"
author: "tucca-rna-seq"
date: "`r Sys.Date()`"
bibliography:
  - grateful-refs.bib
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/nature.csl
link-citations: true
output:
  rmdformats::readthedown:
    code_folding: hide
    self_contained: true
    number_sections: true
    DT: datatable
    toc_depth: 3
    collapsed: true
    css: css/doc.css
    fig_width: 15
    fig_height: 15
    classoption: landscape
---

# Introduction

This RMarkdown document is a playground for interactive exploration of RNA-seq
analysis results from the `tucca-rna-seq` pipeline. It uses the `ideal`
package to visualize and interpret differential expression analysis results.

Before you begin, make sure you have successfully completed a `tucca-rna-seq`
run. The objects generated by the pipeline are required for this analysis.

# Setup

## Load Libraries

First, we load all the necessary R packages.

```{r setup, message=FALSE, warning=FALSE}
# Bootstrap the 'here' package. This ensures that `here` is installed before
# we use it to find the project root.
if (!requireNamespace("here", quietly = TRUE)) {
  utils::install.packages("here", quiet = TRUE)
}

# The `here` package helps us build file paths relative to the project root.
# We'll establish the root by finding the `ideal_playground.Rmd` file
# within the `tucca-rna-seq/analysis` directory. This makes the script
# robust to the current working directory.
here::i_am("tucca-rna-seq/analysis/ideal_playground.Rmd")

# We explicitly tell renv where its project directory is.
# The renv project is in the `tucca-rna-seq` subdirectory.
renv::restore(
  project = here::here(), prompt = FALSE, clean = TRUE
)

# All functions in this notebook will be called with explicit package namespaces
# (e.g., `ideal::ideal()`) to ensure clarity and avoid conflicts.
# This makes `library()` calls unnecessary.
```

# Possible Configurations

```{r possible-configurations}
# Parse the YAML string into an R list
config_path <- here::here(, "config", "config.yaml")
config <- yaml::read_yaml(config_path)

# Extract the list of analyses
analyses_list <- config$diffexp$deseq2$analyses

# Use lapply to iterate over each analysis and extract its contrasts
analysis_contrast_map <- lapply(analyses_list, function(analysis) {
  sapply(analysis$contrasts, `[[`, "name")
})

# Assign the analysis names to the list elements
names(analysis_contrast_map) <- sapply(analyses_list, `[[`, "name")

# Print the resulting R list with a descriptive header
base::cat(
  "Available analyses (as list names) and their corresponding",
  "contrasts (as list values):\n\n"
)
print(analysis_contrast_map)
```

# Your Configuration

Here, you need to specify which analysis and contrast you want to explore.
These names correspond to the configurations in your `config.yaml`.

```{r configuration}
# --- USER INPUT REQUIRED ---
# The values below are examples from the default `config.yaml`.
# Replace them with the `analysis` and `contrast` you wish to explore.
# You can see available options from the output of the previous code chunk.
analysis_name <- "treatment1_treatment2"
contrast_name <- "treatment1_treated_vs_untreated"
```

# Load Data

Now, we load the data generated by the `tucca-rna-seq` pipeline based on the
configuration above.

```{r load_data}
# Construct file paths
wald_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, contrast_name,
  "wald.RDS"
)

# Load the main objects
dds_wald <- base::readRDS(wald_path)
res_de <- DESeq2::results(base::readRDS(wald_path)) # DESeqResults object
config <- yaml::read_yaml(config_path)
```

# Prepare Inputs for ideal

`ideal` requires a few specific inputs: `dds_obj`, `res_obj`,
and `annotation_obj`. We have the first two, now we create the annotation
object.

## Create `annotation_obj`

The `annotation_obj` is a data frame that maps gene IDs to gene names. We'll
create it using the correct organism annotation package.

```{r create_annotation_obj}
# Load the enrichment parameters that were used in the Snakemake run
enrichment_params_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", "enrichment_params.RDS"
)
enrichment_params <- base::readRDS(enrichment_params_path)

# Get OrgDb package name from the loaded parameters.
# This logic mirrors the pipeline scripts to correctly identify the package
# name, whether it was installed from Bioconductor or built locally.
install_method <- enrichment_params$install_method
install_source <- enrichment_params$install_source

# Determine the actual package name
org_db_pkg <- if (install_method == "local") {
  # When built locally, find the package name from the build directory.
  # The path in config.yaml is relative to the project root.
  local_build_path <- here::here(, install_source)
  pkg_dirs <- base::list.dirs(
    path = local_build_path,
    full.names = FALSE, recursive = FALSE
  )
  pkg_name <- pkg_dirs[grepl("^org\\..+\\.db$", pkg_dirs)]
  if (length(pkg_name) == 0) {
    base::stop(
      "Could not find a locally built OrgDb package in the specified",
      "directory: ", local_build_path
    )
  }
  pkg_name[1]
} else {
  enrichment_params$org_db_pkg
}

base::message("Attempting to load OrgDb package: ", org_db_pkg)

# Set a default value for annotation_obj
annotation_obj <- NULL

# Try to load the package. If it's not there, try to install it.
if (!base::require(org_db_pkg, character.only = TRUE)) {
  base::message("Package not found, attempting installation via renv...")
  tryCatch(
    {
      if (install_method == "local") {
        # For a locally built package, we need to provide the path to renv
        local_pkg_path <- here::here(, install_source)
        base::message(
          "Attempting to install local package from: ",
          local_pkg_path
        )
        # We point renv to the directory containing the package source
        renv::install(local_pkg_path, prompt = FALSE)
      } else {
        # For remote packages, renv can find it by name from Bioconductor
        base::message("Attempting to install remote package: ", org_db_pkg)
        renv::install(org_db_pkg, prompt = FALSE)
      }
    },
    error = function(e) {
      base::message(paste("Installation of", org_db_pkg, "failed."))
      base::message("Original error: ", e$message)
    }
  )
}

# Now, try to load it again. If it works, create the annotation object.
if (base::require(org_db_pkg, character.only = TRUE)) {
  # Determine the keytype based on the genome annotation source from config.yaml
  ref_source <- config$ref_assembly$source
  keytype <- if (ref_source %in% c("Ensembl", "GENCODE")) {
    "ENSEMBL"
  } else if (ref_source == "RefSeq") {
    "ENTREZID"
  } else {
    base::warning(paste(
      "Unrecognized ref_assembly.source:", ref_source,
      "- defaulting keytype to ENSEMBL."
    ))
    "ENSEMBL"
  }

  base::message(base::paste(
    "Using", org_db_pkg, "for annotation with keytype '", keytype, "'."
  ))

  # The annotation object needs columns: 'gene_id', 'gene_name'
  # We will map from the appropriate gene IDs based on the keytype
  keys <- utils::head(base::rownames(dds_wald))

  # Determine the correct column for gene symbols, which can vary between OrgDb
  # packages. We create a prioritized list of candidates to check.
  all_cols <- AnnotationDbi::columns(base::get(org_db_pkg))
  symbol_col_candidates <- c("SYMBOL", "GENENAME")
  symbol_col <- NULL

  for (candidate in symbol_col_candidates) {
    if (candidate %in% all_cols) {
      symbol_col <- candidate
      base::message("Found '", symbol_col, "' as the gene symbol column.")
      break
    }
  }

  if (base::is.null(symbol_col)) {
    base::stop(
      "Could not find a suitable gene symbol column in this OrgDb.",
      " Checked for: ", base::paste(symbol_col_candidates, collapse = ", "),
      ". Please inspect `AnnotationDbi::columns(base::get(org_db_pkg))`",
      " and add a valid candidate to `symbol_col_candidates`."
    )
  }

  annotation_obj <- AnnotationDbi::select(
    base::get(org_db_pkg),
    keys = AnnotationDbi::keys(base::get(org_db_pkg), keytype = keytype),
    columns = c(symbol_col),
    keytype = keytype
  ) |>
    dplyr::rename(
      gene_id = dplyr::all_of(keytype),
      gene_name = dplyr::all_of(symbol_col)
    ) |>
    dplyr::filter(!base::is.na(gene_name))
} else {
  base::message(
    "OrgDb package could not be loaded. Please ensure the pipeline",
    "has run successfully and that you are in the correct R environment."
  )
}
```

# Launch ideal

With all the ingredients ready, we can now launch the interactive application.

```{r launch_ideal, eval=interactive()}
if (!base::is.null(dds_wald) && !base::is.null(res_de) && !base::is.null(annotation_obj)) {
  # Launch the app!
  ideal::ideal(
    dds_obj = dds_wald,
    res_obj = res_de,
    annotation_obj = annotation_obj
  )
} else {
  base::message(
    "Could not launch ideal because the dds, results, or annotation objects",
    "are missing."
  )
}
```

# R Session Information

Below is the output of the R session used to generate this report. Included is
information on R version, OS, and versions of packages installed and used.

```{r sessionInfo}
sessionInfo()
```

# References

```{r citation-reports, message=FALSE, warning=FALSE, echo=TRUE}
# Packages to cite
dependencies <- renv::dependencies()
pkgs <- unique(dependencies$Package)

# Create grateful citation report
grateful::cite_packages(
  output = "file",
  out.format = "html",
  citation.style = "nature",
  out.dir = here::here(, "analysis"),
  pkgs = pkgs,
  cite.tidyverse = FALSE,
  include.RStudio = FALSE, # Set to FALSE for automated testing (CI/CD). Set to TRUE for interactive use.
  passive.voice = TRUE
)
```

```{r citation-table, message=FALSE, warning=FALSE, echo = TRUE}
pkgs_tbl <- grateful::cite_packages(
  output = "table",
  citation.style = "nature",
  out.dir = here::here(),
  pkgs = pkgs,
  cite.tidyverse = FALSE,
  include.RStudio = FALSE # Set to FALSE for automated testing (CI/CD). Set to TRUE for interactive use.
)
pkgs_tbl$Citation <- gsub("\\.\\.\\.\\.", "", pkgs_tbl$Citation)
knitr::kable(pkgs_tbl)
```
