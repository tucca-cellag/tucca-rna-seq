---
title: "Interactive Analysis with pcaExplorer"
author: "tucca-rna-seq"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
---

# Introduction

This RMarkdown document is a playground for interactive exploration of RNA-seq
analysis results from the `tucca-rna-seq` pipeline. It uses the `pcaExplorer`
package to visualize and interpret the results of a principal component
analysis.

Before you begin, make sure you have successfully completed a `tucca-rna-seq`
run. The objects generated by the pipeline are required for this analysis.

# Setup

## Load Libraries

First, we load all the necessary R packages.

```{r setup, message=FALSE, warning=FALSE}
# Bootstrap the 'here' package. This ensures that `here` is installed before
# we use it to find the project root.
if (!requireNamespace("here", quietly = TRUE)) {
  utils::install.packages("here", quiet = TRUE)
}

# The `here` package helps us build file paths relative to the project root.
# We'll establish the root by finding the `pcaExplorer_playground.Rmd` file
# within the `tucca-rna-seq/analysis` directory. This makes the script
# robust to the current working directory.
here::i_am("tucca-rna-seq/analysis/pcaExplorer_playground.Rmd")

# We explicitly tell renv where its project directory is.
# The renv project is in the `tucca-rna-seq` subdirectory.
renv::restore(
  project = here::here("tucca-rna-seq"), prompt = FALSE, clean = TRUE
)

# All functions in this notebook will be called with explicit package namespaces
# (e.g., `pcaExplorer::pcaExplorer()`) to ensure clarity and avoid conflicts.
# This makes `library()` calls unnecessary.
```

# Possible Analyses

This chunk reads your `config.yaml` to show which analyses are available.

```{r possible-analyses}
# Parse the YAML string into an R list
config_path <- here::here("tucca-rna-seq", "config", "config.yaml")
config <- yaml::read_yaml(config_path)

# Extract and print the names of the available analyses
analysis_names <- sapply(config$diffexp$deseq2$analyses, `[[`, "name")

base::cat("Available analyses from your config.yaml:\n\n")
print(analysis_names)
```

# Your Configuration

Here, you need to specify which analysis and transformation you want to
explore. These names correspond to the configurations in your `config.yaml`.

```{r configuration}
# --- USER INPUT REQUIRED ---
# The value below is an example from the default `config.yaml`.
# Replace them with the `analysis` you wish to explore.
# You can see available analyses from the output of the previous code chunk.
analysis_name <- "treatment1_treatment2"
```

# Load Data

Now, we load the data generated by the `tucca-rna-seq` pipeline based on the
configuration above. For PCA, it is best to use variance-stabilized data.

```{r load_data}
# Construct file path to the transformed data object
dst_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, "dst.RDS"
)

# Load the main object (a DESeqTransform object)
dst <- base::readRDS(dst_path)
```

# Prepare Inputs for pcaExplorer

`pcaExplorer` requires an annotation object to map gene IDs to gene names. We
will create it using the same logic as the main pipeline.

## Create `annotation_obj`

The `annotation_obj` is a data frame that maps gene IDs to gene names.

```{r create_annotation_obj}
# Load the enrichment parameters that were used in the Snakemake run
enrichment_params_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", "enrichment_params.RDS"
)
enrichment_params <- base::readRDS(enrichment_params_path)

# Get OrgDb package name from the loaded parameters.
# This logic mirrors the pipeline scripts to correctly identify the package
# name, whether it was installed from Bioconductor or built locally.
install_method <- enrichment_params$install_method
install_source <- enrichment_params$install_source

# Determine the actual package name
org_db_pkg <- if (install_method == "local") {
  # When built locally, find the package name from the build directory.
  # The path in config.yaml is relative to the project root.
  local_build_path <- here::here("tucca-rna-seq", install_source)
  pkg_dirs <- base::list.dirs(
    path = local_build_path,
    full.names = FALSE, recursive = FALSE
  )
  pkg_name <- pkg_dirs[grepl("^org\\..+\\.db$", pkg_dirs)]
  if (length(pkg_name) == 0) {
    base::stop(
      "Could not find a locally built OrgDb package in the specified",
      "directory: ", local_build_path
    )
  }
  pkg_name[1]
} else {
  enrichment_params$org_db_pkg
}

base::message("Attempting to load OrgDb package: ", org_db_pkg)

# Set a default value for annotation_obj
annotation_obj <- NULL

# Try to load the package. If it's not there, try to install it.
if (!base::require(org_db_pkg, character.only = TRUE)) {
  base::message("Package not found, attempting installation via renv...")
  tryCatch(
    {
      if (install_method == "local") {
        # For a locally built package, we need to provide the path to renv
        local_pkg_path <- here::here("tucca-rna-seq", install_source)
        base::message(
          "Attempting to install local package from: ",
          local_pkg_path
        )
        # We point renv to the directory containing the package source
        renv::install(local_pkg_path, prompt = FALSE)
      } else {
        # For remote packages, renv can find it by name from Bioconductor
        base::message("Attempting to install remote package: ", org_db_pkg)
        renv::install(org_db_pkg, prompt = FALSE)
      }
    },
    error = function(e) {
      base::message(paste("Installation of", org_db_pkg, "failed."))
      base::message("Original error: ", e$message)
    }
  )
}

# Now, try to load it again. If it works, create the annotation object.
if (base::require(org_db_pkg, character.only = TRUE)) {
  # The annotation object needs columns: 'gene_id', 'gene_name'
  # We will map from ENSEMBL IDs (if they are the rownames of our dds)
  keys <- utils::head(base::rownames(dst))
  keytype <- "ENSEMBL" # Change if your dds uses other identifiers like ENTREZID

  base::message(base::paste("Using", org_db_pkg, "for annotation."))

  # Determine the correct column for gene symbols, which can vary between OrgDb
  # packages. We create a prioritized list of candidates to check.
  all_cols <- AnnotationDbi::columns(base::get(org_db_pkg))
  symbol_col_candidates <- c("SYMBOL", "GENENAME")
  symbol_col <- NULL

  for (candidate in symbol_col_candidates) {
    if (candidate %in% all_cols) {
      symbol_col <- candidate
      base::message("Found '", symbol_col, "' as the gene symbol column.")
      break
    }
  }

  if (base::is.null(symbol_col)) {
    base::stop(
      "Could not find a suitable gene symbol column in this OrgDb.",
      " Checked for: ", base::paste(symbol_col_candidates, collapse = ", "),
      ". Please inspect `AnnotationDbi::columns(base::get(org_db_pkg))`",
      " and add a valid candidate to `symbol_col_candidates`."
    )
  }

  annotation_obj <- AnnotationDbi::select(
    base::get(org_db_pkg),
    keys = AnnotationDbi::keys(base::get(org_db_pkg), keytype = keytype),
    columns = c(symbol_col),
    keytype = keytype
  ) |>
    dplyr::rename(
      gene_id = dplyr::all_of(keytype),
      gene_name = dplyr::all_of(symbol_col)
    ) |>
    dplyr::filter(!base::is.na(gene_name))
} else {
  base::message(
    "OrgDb package could not be loaded. Please ensure the pipeline",
    "has run successfully and that you are in the correct R environment."
  )
}
```

# Launch pcaExplorer

With all the ingredients ready, we can now launch the interactive application.

```{r launch_pcaExplorer, eval=interactive()}
if (!base::is.null(dst) && !base::is.null(annotation_obj)) {
  # Launch the app!
  # We pass the transformed data `dst` as the `dds` argument, as recommended
  # by the pcaExplorer documentation for optimal performance.
  pcaExplorer::pcaExplorer(dds = dst, annotation = annotation_obj)
} else {
  base::message(
    "Could not launch pcaExplorer because the data or annotation objects are",
    "missing."
  )
}
```

# Reporting with `report`

`pcaExplorer` also provides a function called `report()` to create a
non-interactive HTML report summarizing key results. This is useful for sharing
your findings.

```{r report, eval=FALSE}
# Example of how to generate a report - uncomment and customize to run
#
# pcaExplorer::report(
#   dds = dst,
#   annotation = annotation_obj,
#   report_dir = "pcaExplorer_report" # A directory to save the report
# )
``` 