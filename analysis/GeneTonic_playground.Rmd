---
title: "Interactive Analysis with GeneTonic"
author: "tucca-rna-seq"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
---

# Introduction

This RMarkdown document is a playground for interactive exploration of RNA-seq
analysis results from the `tucca-rna-seq` pipeline. It uses the `GeneTonic`
package to visualize and interpret differential expression and enrichment
analysis results.

Before you begin, make sure you have successfully completed a `tucca-rna-seq`
run. The objects generated by the pipeline are required for this analysis.

# Setup

## Load Libraries

First, we load all the necessary R packages.

```{r setup, message=FALSE, warning=FALSE}
# Bootstrap the 'here' package. This ensures that `here` is installed before
# we use it to find the project root.
if (!requireNamespace("here", quietly = TRUE)) {
  utils::install.packages("here", quiet = TRUE)
}

# The `here` package helps us build file paths relative to the project root.
# We'll establish the root by finding the `GeneTonic_playground.Rmd` file
# within the `tucca-rna-seq/analysis` directory. This makes the script
# robust to the current working directory.
here::i_am("tucca-rna-seq/analysis/GeneTonic_playground.Rmd")

# We explicitly tell renv where its project directory is.
# The renv project is in the `tucca-rna-seq` subdirectory.
renv::restore(
  project = here::here("tucca-rna-seq"),
  prompt = FALSE, clean = TRUE
)

# All functions in this notebook will be called with explicit package namespaces
# (e.g., `GeneTonic::GeneTonic()`) to ensure clarity and avoid conflicts.
# This makes `library()` calls unnecessary.
```

# Possible Configurations

```{r possible-configurations}
# Parse the YAML string into an R list
config_path <- here::here("tucca-rna-seq", "config", "config.yaml")
config <- yaml::read_yaml(config_path)

# Extract the list of analyses
analyses_list <- config$diffexp$deseq2$analyses

# Use lapply to iterate over each analysis and extract its contrasts
analysis_contrast_map <- lapply(analyses_list, function(analysis) {
  sapply(analysis$contrasts, `[[`, "name")
})

# Assign the analysis names to the list elements
names(analysis_contrast_map) <- sapply(analyses_list, `[[`, "name")

# Print the resulting R list with a descriptive header
base::cat(
  "Available analyses (as list names) and their corresponding",
  "contrasts (as list values):\n\n"
)
print(analysis_contrast_map)
```

# Your Configuration

Here, you need to specify which analysis and contrast you want to explore.
These names correspond to the configurations in your `config.yaml`.

```{r configuration}
# --- USER INPUT REQUIRED ---
# The values below are examples from the default `config.yaml`.
# Replace them with the `analysis` and `contrast` you wish to explore.
# You can see available options from the output of the previous code chunk.
analysis_name <- "treatment1_treatment2"
contrast_name <- "treatment1_treated_vs_untreated"
```

# Load Data

Now, we load the data generated by the `tucca-rna-seq` pipeline based on the
configuration above.

```{r load_data}
# Construct file paths
dds_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, "dds.RDS"
)
res_path <- here::here(
  "tucca-rna-seq", "resources", "deseq2", analysis_name, contrast_name,
  "wald.RDS"
)
ora_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", analysis_name, contrast_name,
  "ora_results.RDS"
)
gsea_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", analysis_name, contrast_name,
  "gsea_results.RDS"
)

# Load the main objects
dds <- base::readRDS(dds_path)
res_de <- base::readRDS(res_path) # This is the DESeqResults object
ora_results <- base::readRDS(ora_path)
gsea_results <- base::readRDS(gsea_path)
config <- yaml::read_yaml(config_path)

# The results objects are lists (e.g., for GO and KEGG).
# We will select one for the GeneTonic visualization.
res_enrich <- gsea_results$GO # or gsea_results$KEGG, or ora_results$GO, etc.
```

# Prepare Inputs for GeneTonic

`GeneTonic` requires a few specific inputs: `dds`, `res_de`, `res_enrich`, and
`annotation_obj`. We have the first three, now we create the annotation object.

## Create `annotation_obj`

The `annotation_obj` is a data frame that maps gene IDs to gene names. We'll
create it using the correct organism annotation package.

```{r create_annotation_obj}
# Load the enrichment parameters that were used in the Snakemake run
enrichment_params_path <- here::here(
  "tucca-rna-seq", "resources", "enrichment", "enrichment_params.RDS"
)
enrichment_params <- base::readRDS(enrichment_params_path)

# Get OrgDb package name from the loaded parameters.
# This logic mirrors the pipeline scripts to correctly identify the package
# name, whether it was installed from Bioconductor or built locally.
install_method <- enrichment_params$install_method
install_source <- enrichment_params$install_source

# Determine the actual package name
org_db_pkg <- if (install_method == "local") {
  # When built locally, find the package name from the build directory.
  # The path in config.yaml is relative to the project root.
  local_build_path <- here::here("tucca-rna-seq", install_source)
  pkg_dirs <- base::list.dirs(
    path = local_build_path,
    full.names = FALSE, recursive = FALSE
  )
  pkg_name <- pkg_dirs[grepl("^org\\..+\\.db$", pkg_dirs)]
  if (length(pkg_name) == 0) {
    base::stop(
      "Could not find a locally built OrgDb package in the specified",
      "directory: ", local_build_path
    )
  }
  pkg_name[1]
} else {
  enrichment_params$org_db_pkg
}

base::message("Attempting to load OrgDb package: ", org_db_pkg)

# Set a default value for annotation_obj
annotation_obj <- NULL

# Try to load the package. If it's not there, try to install it.
if (!base::require(org_db_pkg, character.only = TRUE)) {
  base::message("Package not found, attempting installation via renv...")
  tryCatch(
    {
      if (install_method == "local") {
        # For a locally built package, we need to provide the path to renv
        local_pkg_path <- here::here("tucca-rna-seq", install_source)
        base::message(
          "Attempting to install local package from: ",
          local_pkg_path
        )
        # We point renv to the directory containing the package source
        renv::install(local_pkg_path, prompt = FALSE)
      } else {
        # For remote packages, renv can find it by name from Bioconductor
        base::message("Attempting to install remote package: ", org_db_pkg)
        renv::install(org_db_pkg, prompt = FALSE)
      }
    },
    error = function(e) {
      base::message(paste("Installation of", org_db_pkg, "failed."))
      base::message("Original error: ", e$message)
    }
  )
}

# Now, try to load it again. If it works, create the annotation object.
if (base::require(org_db_pkg, character.only = TRUE)) {
  # The annotation object needs columns: 'gene_id', 'gene_name'
  # We will map from ENSEMBL IDs (if they are the rownames of our dds)
  keys <- utils::head(base::rownames(dds))
  keytype <- "ENSEMBL" # Change if your dds uses other identifiers like ENTREZID

  base::message(base::paste("Using", org_db_pkg, "for annotation."))

  # Determine the correct column for gene symbols, which can vary between OrgDb
  # packages (e.g., 'SYMBOL' vs. 'GENENAME').
  all_cols <- AnnotationDbi::columns(base::get(org_db_pkg))
  symbol_col <- "SYMBOL"
  if (!symbol_col %in% all_cols) {
    base::message(
      "'SYMBOL' column not found. Searching for 'GENENAME' as an alternative."
    )
    if ("GENENAME" %in% all_cols) {
      symbol_col <- "GENENAME"
      base::message("Found 'GENENAME' as the gene symbol column.")
    } else {
      base::stop(
        "Could not find a 'SYMBOL' or 'GENENAME' column in this OrgDb.",
        " Please inspect `AnnotationDbi::columns(base::get(org_db_pkg))`",
        " and manually set the `symbol_col` variable in this script."
      )
    }
  }

  annotation_obj <- AnnotationDbi::select(
    base::get(org_db_pkg),
    keys = AnnotationDbi::keys(base::get(org_db_pkg), keytype = keytype),
    columns = c(symbol_col),
    keytype = keytype
  ) |>
    dplyr::rename(
      gene_id = dplyr::all_of(keytype),
      gene_name = dplyr::all_of(symbol_col)
    ) |>
    dplyr::filter(!base::is.na(gene_name))
} else {
  base::message(
    "OrgDb package could not be loaded. Please ensure the pipeline",
    "has run successfully and that you are in the correct R environment."
  )
}
```

## "Shake" the enrichment results

`GeneTonic` has `shake_` functions to convert standard enrichment result
objects into the required `data.frame` format.

```{r shake_results}
# We will use the 'shaken' version of the enrichment results
# This function is smart enough to handle both gseaResult and enrichResult
res_enrich_shaken <- GeneTonic::shake_topGOtableResult(res_enrich)
```

# Launch GeneTonic

With all the ingredients ready, we can now create the `GeneTonicList` object
and launch the interactive application.

```{r launch_gene_tonic, eval=interactive()}
if (!base::is.null(res_enrich) && !base::is.null(annotation_obj)) {
  # Create the GeneTonicList object
  gtl <- GeneTonic::GeneTonicList(
    dds = dds,
    res_de = res_de,
    res_enrich = res_enrich_shaken,
    annotation_obj = annotation_obj
  )

  # Launch the app!
  GeneTonic::GeneTonic(gtl = gtl, project_id = "My Project")
} else {
  base::message("Could not launch GeneTonic because enrichment results or annotation object are missing.")
}
```

# Reporting with `happy_hour`

`GeneTonic` also provides a function called `happy_hour()` to create a
non-interactive HTML report summarizing key results. This is useful for
sharing your findings.

You can select genes and gene sets of interest to focus the report.

```{r happy_hour, eval=FALSE}
# Example of how to run happy_hour - uncomment and customize to run
# my_genesets <- utils::head(res_enrich_shaken$gs_id, 5)
# my_genes <- base::c("GENE1_ID", "GENE2_ID") # Replace with gene IDs of interest
#
# GeneTonic::happy_hour(
#   gtl = gtl,
#   project_id = "MyReport",
#   mygenesets = my_genesets,
#   mygenes = my_genes,
#   open_after_creating = TRUE
# )
``` 